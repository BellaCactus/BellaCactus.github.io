<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>rain • bella cactus</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" type="image/png" href="twi looking.png" />

  <style>
    :root{
      --bg:#070707;
      --bg2:#0b0b0b;
      --panel: rgba(255,255,255,0.055);
      --panel2: rgba(255,255,255,0.03);
      --border: rgba(255,255,255,0.10);
      --text:#f7f7f7;
      --muted:#b9b9c2;
      --pink:#ff78c8;
      --pink2:#ffb3e6;
      --pink3:#ff4db8;
      --shadow: 0 20px 70px rgba(0,0,0,0.55);
      --radius:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    }

    *{box-sizing:border-box;}
    html,body{height:100%;}
    body{
      margin:0;
      background:
        radial-gradient(900px 600px at 15% 12%, rgba(255,120,200,0.12), transparent 55%),
        radial-gradient(900px 600px at 90% 30%, rgba(255,179,230,0.10), transparent 55%),
        radial-gradient(1200px 700px at 40% 95%, rgba(255,77,184,0.08), transparent 55%),
        linear-gradient(180deg, var(--bg), var(--bg2));
      color:var(--text);
      font-family: var(--sans);
      line-height:1.55;
      overflow-x:hidden;
    }

    a{color:var(--pink); text-decoration:none;}
    a:hover{text-decoration:underline;}

    .pulseText{
      background: linear-gradient(90deg, #ffffff, var(--pink), #ffffff, var(--pink2), #ffffff);
      background-size: 260% 100%;
      -webkit-background-clip:text;
      background-clip:text;
      color:transparent;
      animation: shimmer 4.8s ease-in-out infinite;
    }
    @keyframes shimmer{
      0%{background-position:0% 50%;}
      50%{background-position:100% 50%;}
      100%{background-position:0% 50%;}
    }

    .wrap{
      max-width:1100px;
      margin:0 auto;
      padding:44px 16px 110px;
      position:relative;
      z-index:2;
    }

    .top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:14px;
      margin-bottom:18px;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:14px;
      min-width:0;
    }
    .badge{
      width:56px;height:56px;border-radius:14px;
      background: linear-gradient(180deg, rgba(255,120,200,0.22), rgba(255,120,200,0.06));
      border:1px solid rgba(255,120,200,0.25);
      display:grid;place-items:center;
      box-shadow: var(--shadow);
      overflow:hidden;
      flex: 0 0 auto;
    }
    .badge img{ width:100%; height:100%; object-fit:cover; filter:saturate(1.05) contrast(1.05); }
    h1{
      margin:0;
      font-size:2rem;
      letter-spacing:0.4px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .sub{
      margin:4px 0 0;
      color:var(--muted);
      font-size:0.98rem;
      max-width:640px;
    }

    .chips{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .chip{
      font-size:0.82rem;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color:var(--muted);
      backdrop-filter: blur(6px);
      font-family: var(--mono);
      user-select:none;
    }
    .chip .dot{
      display:inline-block;width:6px;height:6px;border-radius:999px;margin-right:6px;
      background:var(--pink);
      box-shadow:0 0 12px rgba(255,120,200,0.6);
    }

    .grid{
      display:grid;
      grid-template-columns: 1.25fr 0.75fr;
      gap:14px;
      margin-top:14px;
    }
    @media (max-width: 940px){
      .grid{grid-template-columns:1fr;}
      .chips{justify-content:flex-start;}
    }

    .panel{
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
      backdrop-filter: blur(6px);
    }
    .panelTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:14px 16px;
      border-bottom:1px solid rgba(255,255,255,0.06);
      background: rgba(0,0,0,0.18);
    }
    .panelTitle h2{ margin:0; font-size:1.05rem; color:var(--pink2); letter-spacing:0.3px; }
    .small{ font-size:0.86rem; color:var(--muted); font-family: var(--mono); }
    .panelInner{ padding:16px; }

    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; align-items:center; }
    .btn{
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
      color:var(--text);
      transition: transform 0.08s ease, background 0.2s ease, border 0.2s ease, opacity 0.2s ease;
      text-decoration:none;
      user-select:none;
    }
    .btn:hover{
      text-decoration:none;
      transform: translateY(-1px);
      border-color: rgba(255,120,200,0.35);
      background: rgba(255,120,200,0.10);
    }
    .btn:active{ transform: translateY(0); opacity:0.95; }
    .btn .k{ font-family: var(--mono); font-size:0.8rem; color:var(--pink2); }

    .stage{
      position:relative;
      border-radius:16px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.35);
      height: min(70vh, 620px);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }
    canvas#cv{ width:100%; height:100%; display:block; }

    .scan{
      pointer-events:none;
      position:absolute;
      inset:0;
      opacity:0.22;
      mix-blend-mode: screen;
      background:
        radial-gradient(800px 600px at 40% 20%, rgba(255,120,200,0.10), transparent 60%),
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,0.045) 0px,
          rgba(255,255,255,0.045) 1px,
          rgba(0,0,0,0) 3px,
          rgba(0,0,0,0) 7px
        ),
        radial-gradient(1200px 900px at 50% 40%, transparent 55%, rgba(0,0,0,0.65) 100%);
      animation: drift 6.8s linear infinite;
    }
    @keyframes drift{
      0%{ transform: translateY(0); }
      100%{ transform: translateY(18px); }
    }

    .hud{
      position:absolute;
      left:10px;
      top:10px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      z-index:4;
      pointer-events:none;
      font-family: var(--mono);
      font-size:12px;
    }
    .hud .pill{
      pointer-events:none;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.34);
      color: rgba(255,255,255,0.84);
      backdrop-filter: blur(6px);
      display:inline-flex;
      align-items:center;
      gap:8px;
      box-shadow: 0 12px 35px rgba(0,0,0,0.45);
    }
    .hud .pill .dot{
      width:7px;height:7px;border-radius:999px;
      background: var(--pink);
      box-shadow:0 0 12px rgba(255,120,200,0.55);
    }

    .field{ display:flex; flex-direction:column; gap:6px; margin-top:10px; }
    input[type="range"]{ accent-color: var(--pink); width:100%; }
    .tog{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.22);
      color:var(--muted);
      font-family: var(--mono);
      font-size:0.82rem;
      user-select:none;
      width: fit-content;
    }
    .tog input{ accent-color: var(--pink); }

    .codebox{
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.35;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 12px;
      color: rgba(255,255,255,0.92);
      overflow:auto;
    }
    .codebox .pink{ color:var(--pink2); text-shadow:0 0 10px rgba(255,120,200,0.25); }

    .oneko{
      position:fixed;
      bottom:12px;
      right:12px;
      z-index:5;
      opacity:0.95;
      filter: drop-shadow(0 14px 28px rgba(0,0,0,0.6));
      animation: floaty 3.6s ease-in-out infinite;
      cursor:pointer;
      user-select:none;
    }
    @keyframes floaty{
      0%{transform: translateY(0);}
      50%{transform: translateY(-6px);}
      100%{transform: translateY(0);}
    }
    .oneko img{ width:52px; image-rendering:pixelated; display:block; }

    @media (prefers-reduced-motion: reduce){
      .pulseText{ animation:none; }
      .scan{ animation:none; }
      .oneko{ animation:none; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="top">
      <div class="brand">
        <div class="badge" aria-hidden="true">
          <img src="twi looking.png" alt="badge" />
        </div>
        <div class="titlebox">
          <h1 class="pulseText">rain biome</h1>
          <div class="sub">tiny creature + endless rain. hop platforms, collect glow spores, hide in shelter.</div>
        </div>
      </div>

      <div class="chips">
        <div class="chip"><span class="dot"></span> <span class="pulseText">black/white/pink</span></div>
        <div class="chip" id="chipSpore">spores: 0</div>
        <div class="chip" id="chipBest">best: 0</div>
        <div class="chip" id="chipState">state: calm</div>
      </div>
    </div>

    <div class="grid">
      <section class="panel">
        <div class="panelTitle">
          <h2>playfield</h2>
          <div class="small">move: <span class="pulseText">wasd</span>/<span class="pulseText">arrows</span> • jump: <span class="pulseText">space</span> (double) • dash: <span class="pulseText">shift</span> (tap) • reset: <span class="pulseText">r</span></div>
        </div>
        <div class="panelInner">
          <div class="btnRow">
            <a class="btn" href="index.html"><span class="k">cd</span> home</a>
            <button class="btn" id="btnReset" type="button"><span class="k">rst</span> reset</button>
            <button class="btn" id="btnReroll" type="button"><span class="k">rng</span> reroll biome</button>
            <button class="btn" id="btnPause" type="button"><span class="k">⏸</span> pause</button>
            <button class="btn" id="btnScreenshot" type="button" title="downloads a png"><span class="k">cam</span> screenshot</button>
          </div>

          <div class="stage" id="stage">
            <canvas id="cv" aria-label="rain creature canvas"></canvas>
            <div class="scan"></div>

            <div class="hud" aria-hidden="true">
              <div class="pill"><span class="dot"></span><span id="hudHp">hp: 6/6</span></div>
              <div class="pill"><span class="dot"></span><span id="hudWet">wet: 0%</span></div>
              <div class="pill"><span class="dot"></span><span id="hudWind">wind: 0.0</span></div>
              <div class="pill"><span class="dot"></span><span id="hudAir">air: 1j 1d</span></div>
            </div>
          </div>

          <div class="small" style="margin-top:10px;">
            notes: settings + best score save in localStorage. (also yes it is intentionally soggy.)
          </div>
        </div>
      </section>

      <aside class="panel">
        <div class="panelTitle">
          <h2>controls</h2>
          <div class="small pulseText">tune the weather</div>
        </div>
        <div class="panelInner">
          <div class="field">
            <div class="small">jump height: <span id="vJump">372</span></div>
            <input id="rngJump" type="range" min="240" max="520" step="1" value="372">
          </div>

          <div class="field">
            <div class="small">rain intensity: <span id="vRain">0.70</span></div>
            <input id="rngRain" type="range" min="0" max="1" step="0.01" value="0.70">
          </div>

          <div class="field">
            <div class="small">wind: <span id="vWind">0.35</span></div>
            <input id="rngWind" type="range" min="0" max="1" step="0.01" value="0.35">
          </div>

          <div class="field">
            <div class="small">thunder chance: <span id="vThunder">0.22</span></div>
            <input id="rngThunder" type="range" min="0" max="0.8" step="0.01" value="0.22">
          </div>

          <div class="btnRow">
            <label class="tog" title="reduce screen shake + lightning + particle count">
              <input id="chkSoft" type="checkbox">
              soft mode
            </label>

            <label class="tog" title="turn on a tiny ambient hum (requires click on page sometimes)">
              <input id="chkHum" type="checkbox">
              hum
            </label>
          </div>

          <div class="field">
            <div class="small">debug</div>
            <div class="codebox" id="dbg">
              <span class="pink">[biome]</span> seed: <span id="seedOut">000000</span><br>
              <span class="pink">[shelter]</span> status: <span id="shelterOut">stable</span><br>
              <span class="pink">[mood]</span> <span id="moodOut">soft rain</span>
            </div>
          </div>

          <div class="field">
            <div class="small">sprite (target vibe)</div>
            <div class="codebox">
<pre style="margin:0; white-space:pre-wrap;">
<(=^..^=)====9###9o
   \__/\__/\__/\_/
</pre>
            </div>
          </div>
        </div>
      </aside>
    </div>
  </div>

  <div class="oneko" id="oneko" title="click me">
    <img id="onekoImg" src="oneko.gif" alt="oneko" />
  </div>

  <audio id="yeah" preload="auto">
    <source src="lil-jon-yeah.mp3" type="audio/mpeg" />
  </audio>

  <script>
    // -------- helpers
    const $ = (id) => document.getElementById(id);
    const clamp = (n,a,b) => Math.max(a, Math.min(b,n));
    const lerp = (a,b,t) => a + (b-a)*t;

    // oneko fallback + click
    const onekoImg = $("onekoImg");
    onekoImg.addEventListener("error", () => {
      if (!onekoImg.dataset.tried) { onekoImg.dataset.tried="1"; onekoImg.src="onekogif"; }
    });
    $("oneko").addEventListener("click", () => {
      const y = $("yeah");
      y.currentTime = 0;
      y.play().catch(()=>{});
    });

    // -------- settings (saved)
    const SKEY = "bella.rainpage.v3";
    const BEST_KEY = "bella.rainpage.best.v1";

    const ui = {
      jump: $("rngJump"),
      rain: $("rngRain"),
      wind: $("rngWind"),
      thunder: $("rngThunder"),
      soft: $("chkSoft"),
      hum: $("chkHum")
    };

    function loadSettings(){
      try{
        const raw = localStorage.getItem(SKEY);
        if (!raw) return null;
        const j = JSON.parse(raw);
        return j && typeof j === "object" ? j : null;
      }catch(e){ return null; }
    }
    function saveSettings(){
      const j = {
        jump: Number(ui.jump.value),
        rain: Number(ui.rain.value),
        wind: Number(ui.wind.value),
        thunder: Number(ui.thunder.value),
        soft: !!ui.soft.checked,
        hum: !!ui.hum.checked
      };
      localStorage.setItem(SKEY, JSON.stringify(j));
    }
    function applySettings(s){
      if (!s) return;
      if (Number.isFinite(s.jump)) ui.jump.value = String(clamp(s.jump,240,520));
      if (Number.isFinite(s.rain)) ui.rain.value = String(clamp(s.rain,0,1));
      if (Number.isFinite(s.wind)) ui.wind.value = String(clamp(s.wind,0,1));
      if (Number.isFinite(s.thunder)) ui.thunder.value = String(clamp(s.thunder,0,0.8));
      ui.soft.checked = !!s.soft;
      ui.hum.checked = !!s.hum;
    }

    function getBest(){
      const n = Number(localStorage.getItem(BEST_KEY) || "0");
      return Number.isFinite(n) ? n : 0;
    }
    function setBest(n){
      const v = Math.max(0, Math.floor(n));
      localStorage.setItem(BEST_KEY, String(v));
    }

    applySettings(loadSettings());
    $("chipBest").textContent = `best: ${getBest()}`;

    // -------- audio hum (optional)
    let audioCtx = null;
    let humNode = null;
    let humGain = null;

    function setupHum(){
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      humNode = audioCtx.createOscillator();
      humGain = audioCtx.createGain();
      humNode.type = "triangle";
      humNode.frequency.value = 52;
      humGain.gain.value = 0;
      humNode.connect(humGain);
      humGain.connect(audioCtx.destination);
      humNode.start();
    }

    async function resumeAudio(){
      if (!audioCtx) return;
      if (audioCtx.state === "suspended") await audioCtx.resume();
    }

    function setHum(on){
      if (on){
        setupHum();
        resumeAudio().catch(()=>{});
        const t = audioCtx.currentTime;
        humGain.gain.cancelScheduledValues(t);
        humGain.gain.setValueAtTime(humGain.gain.value, t);
        humGain.gain.linearRampToValueAtTime(0.03, t + 0.6);
      } else if (audioCtx && humGain){
        const t = audioCtx.currentTime;
        humGain.gain.cancelScheduledValues(t);
        humGain.gain.setValueAtTime(humGain.gain.value, t);
        humGain.gain.linearRampToValueAtTime(0.0, t + 0.35);
      }
    }

    document.addEventListener("click", () => {
      if (ui.hum.checked) setHum(true);
    }, { once:true });

    // -------- canvas setup
    const stage = $("stage");
    const cv = $("cv");
    const ctx = cv.getContext("2d");

    function fit(){
      const dpr = devicePixelRatio || 1;
      const r = stage.getBoundingClientRect();
      cv.width = Math.floor(r.width * dpr);
      cv.height = Math.floor(r.height * dpr);
      cv.style.width = r.width + "px";
      cv.style.height = r.height + "px";
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    addEventListener("resize", fit);
    fit();

    // -------- tiny seeded rng
    let seed = (Math.random()*1e9)>>>0;
    function sRand(){
      seed ^= seed << 13; seed >>>= 0;
      seed ^= seed >> 17; seed >>>= 0;
      seed ^= seed << 5;  seed >>>= 0;
      return (seed >>> 0) / 4294967296;
    }
    function reseed(){
      seed = (Math.random()*1e9)>>>0;
      $("seedOut").textContent = String(seed).padStart(6,"0").slice(-6);
    }
    reseed();

    // -------- world
    function W(){ return stage.clientWidth; }
    function H(){ return stage.clientHeight; }

    let paused = false;

    // biome params
    let windTarget = 0.0;
    let windNow = 0.0;

    // storm cycle
    let storm = {
      t: 0,
      phase: "calm",
      nextLightning: 1.2,
      flash: 0,
      shake: 0
    };

    function setChipState(txt){
      $("chipState").textContent = `state: ${txt}`;
    }

    // platforms
    let plats = [];
    let shelter = { x: 0, y: 0, w: 120, h: 72 };

    function makePlatforms(){
      const w = W(), h = H();
      plats = [];

      plats.push({ x: -200, y: h-52, w: w+400, h: 80, kind:"ground" });

      const baseY = h - 180 - sRand()*40;
      plats.push({ x: 80 + sRand()*40, y: baseY, w: 230 + sRand()*120, h: 18, kind:"ledge" });
      plats.push({ x: w*0.55 + sRand()*30, y: h - 220 - sRand()*60, w: 260 + sRand()*120, h: 18, kind:"ledge" });
      plats.push({ x: w*0.25 + sRand()*40, y: h - 320 - sRand()*80, w: 160 + sRand()*90, h: 16, kind:"thin" });
      plats.push({ x: w*0.65 + sRand()*40, y: h - 360 - sRand()*90, w: 170 + sRand()*110, h: 16, kind:"thin" });

      plats.push({ x: w*0.44, y: h-260, w: 24, h: 208, kind:"pillar" });
      if (sRand() < 0.65) plats.push({ x: w*0.76, y: h-300, w: 20, h: 250, kind:"pillar" });

      shelter.w = 140;
      shelter.h = 84;
      shelter.x = Math.floor(w - shelter.w - 40 - sRand()*50);
      shelter.y = Math.floor(h - 52 - shelter.h - 2);
    }
    makePlatforms();

    // -------- creature (physics + moveset)
    const player = {
      x: 80, y: 200,
      vx: 0, vy: 0,
      w: 26, h: 16,
      onGround: false,
      face: 1,
      blink: 0,
      bob: 0,
      inv: 0,

      jumpsLeft: 1,
      canDash: true,
      dashTimer: 0,
      dashCd: 0
    };

    let hp = 6;
    let wetness = 0;
    let spores = 0;

    // tail physics (spine chain)
    const tail = {
      segs: 12,
      len: 7.2,
      pts: [],
      initialized: false
    };

    function initTail(){
      tail.pts = [];
      const bx = player.x + player.w/2;
      const by = player.y + 9;
      for (let i=0;i<tail.segs;i++){
        tail.pts.push({ x: bx - i*tail.len, y: by, vx:0, vy:0 });
      }
      tail.initialized = true;
    }

    function updateChips(){
      $("chipSpore").textContent = `spores: ${spores}`;
      $("chipBest").textContent = `best: ${getBest()}`;
      $("hudHp").textContent = `hp: ${hp}/6`;
      $("hudWet").textContent = `wet: ${Math.round(wetness)}%`;
      $("hudWind").textContent = `wind: ${windNow.toFixed(1)}`;
      $("hudAir").textContent = `air: ${player.jumpsLeft}j ${player.canDash?1:0}d`;
    }

    function inShelter(px,py){
      const cx = px + player.w/2;
      const cy = py + player.h/2;
      return (cx > shelter.x + 16 && cx < shelter.x + shelter.w - 16 &&
              cy > shelter.y + 18 && cy < shelter.y + shelter.h - 10);
    }

    // -------- input (edge-triggered)
    const held = new Set();
    const pressed = new Set();

    function normKey(e){
      const k = (e.key || "").toLowerCase();
      if (k === " ") return "space";
      return k;
    }

    addEventListener("keydown", (e) => {
      const k = normKey(e);

      if (["arrowleft","arrowright","arrowup","arrowdown","a","d","w","s","space","shift","r","escape","p"].includes(k)){
        if (["arrowup","arrowdown","arrowleft","arrowright","space"].includes(k)) e.preventDefault();
      }

      if (k === "escape") location.href = "index.html";
      if (k === "p") { togglePause(); return; }
      if (k === "r") { rollBiome(); return; }

      if (!e.repeat) pressed.add(k);
      held.add(k);
    }, { passive:false });

    addEventListener("keyup", (e) => {
      const k = normKey(e);
      held.delete(k);
    });

    function anyHeld(...names){
      for (const n of names) if (held.has(n)) return true;
      return false;
    }
    function anyPressed(...names){
      for (const n of names) if (pressed.has(n)) return true;
      return false;
    }

    // -------- collectibles (glow spores)
    let sporeList = [];

    function spawnSpores(reset=false){
      if (reset) sporeList = [];
      const w = W(), h = H();
      const target = ui.soft.checked ? 8 : 14;
      while (sporeList.length < target){
        const x = 60 + sRand() * (w - 120);
        const y = 80 + sRand() * (h - 260);
        if (x > shelter.x && x < shelter.x + shelter.w && y > shelter.y && y < shelter.y + shelter.h) continue;
        sporeList.push({
          x, y,
          r: 6 + sRand()*4,
          bob: sRand()*Math.PI*2,
          vx: (sRand()-0.5) * 0.2,
          alive: true
        });
      }
    }
    spawnSpores(true);

    function collectCheck(){
      const cx = player.x + player.w/2;
      const cy = player.y + player.h/2;
      for (const s of sporeList){
        if (!s.alive) continue;
        const dx = cx - s.x;
        const dy = cy - s.y;
        if (dx*dx + dy*dy < (s.r + 12) * (s.r + 12)){
          s.alive = false;
          spores++;
          const best = getBest();
          if (spores > best) setBest(spores);
          updateChips();
          if (wetness > 70 && hp < 6 && Math.random() < 0.35) hp++;
        }
      }
      if (sporeList.filter(s => s.alive).length < (ui.soft.checked ? 5 : 8)){
        spawnSpores(false);
      }
    }

    // -------- rain particles
    let drops = [];
    function makeRain(){
      drops = [];
      const w = W(), h = H();
      const baseCount = ui.soft.checked ? 240 : 500;
      const intensity = Number(ui.rain.value);
      const n = Math.floor(lerp(60, baseCount, intensity));
      for (let i=0;i<n;i++){
        drops.push({
          x: sRand() * w,
          y: sRand() * h,
          z: sRand(),
          spd: 380 + sRand()*520,
          len: 8 + sRand()*16
        });
      }
    }
    makeRain();

    let splashes = [];
    function addSplash(x,y,amt=1){
      const n = ui.soft.checked ? 2 : Math.floor(2 + amt*4);
      for (let i=0;i<n;i++){
        splashes.push({
          x, y,
          vx: (Math.random()-0.5) * (30 + Math.random()*60),
          vy: - (40 + Math.random()*90),
          t: 0,
          life: 0.35 + Math.random()*0.25
        });
      }
    }

    // -------- physics + collision
    function aabb(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function tailKick(str=1){
      if (!tail.initialized) return;
      const fx = -player.face * (110 + Math.abs(player.vx)*0.10) * str;
      const fy = (player.vy < 0 ? 60 : -25) * str;
      for (let i=1;i<tail.pts.length;i++){
        tail.pts[i].vx += fx * (0.004 + i*0.0007);
        tail.pts[i].vy += fy * (0.003 + i*0.0006);
      }
    }

    function doJump(isDouble=false){
      const base = Number(ui.jump.value); // <- bella asked for variable jump height
      const v = isDouble ? base * 0.90 : base;
      player.vy = -v;
      player.onGround = false;
      addSplash(player.x + player.w/2, player.y + player.h + 2, isDouble ? 1.0 : 0.7);
      tailKick(0.85 + Math.random()*0.25);
    }

    function startDash(){
      const soft = ui.soft.checked;
      player.dashTimer = soft ? 0.14 : 0.12;
      player.dashCd = soft ? 0.12 : 0.08;
      player.canDash = false;

      const dashV = soft ? 420 : 520;
      player.vx = player.face * dashV;
      player.vy = 0;
      storm.shake = Math.min(1, storm.shake + (soft ? 0.08 : 0.16));
      tailKick(1.25);
    }

    function stepPlayer(dt){
      const w = W(), h = H();
      const soft = ui.soft.checked;

      player.dashCd = Math.max(0, player.dashCd - dt);
      player.dashTimer = Math.max(0, player.dashTimer - dt);

      const move = (anyHeld("a","arrowleft") ? -1 : 0) + (anyHeld("d","arrowright") ? 1 : 0);
      if (move !== 0) player.face = move;

      const accel = soft ? 980 : 1320;
      const maxSpd = soft ? 190 : 240;

      const inDash = player.dashTimer > 0.0001;

      if (!inDash){
        if (move !== 0){
          player.vx += move * accel * dt;
        } else {
          player.vx *= Math.pow(soft ? 0.0007 : 0.00035, dt);
        }
        player.vx = clamp(player.vx, -maxSpd, maxSpd);
      } else {
        player.vx += move * (soft ? 240 : 300) * dt;
        player.vx = clamp(player.vx, - (soft ? 520 : 620), (soft ? 520 : 620));
      }

      const wantsJump = anyPressed("space","w","arrowup");
      if (wantsJump){
        if (player.onGround){
          player.jumpsLeft = 1;
          doJump(false);
        } else if (player.jumpsLeft > 0){
          player.jumpsLeft--;
          doJump(true);
        }
      }

      const wantsDash = anyPressed("shift");
      if (wantsDash && player.canDash && player.dashCd <= 0){
        startDash();
      }

      if (!inDash){
        const g = soft ? 840 : 1000;
        player.vy += g * dt;
      } else {
        player.vy += (soft ? 120 : 140) * dt;
      }
      player.vy = clamp(player.vy, -999, 920);

      let nx = player.x + player.vx * dt;
      let ny = player.y + player.vy * dt;

      nx = clamp(nx, 10, w - player.w - 10);
      if (ny > h + 220){
        ny = 140;
        nx = 80;
        player.vy = 0;
        player.vx = 0;
        hp = Math.max(0, hp-1);
        player.jumpsLeft = 1;
        player.canDash = true;
      }

      player.onGround = false;

      const boxV = { x:nx, y:ny, w:player.w, h:player.h };
      for (const p of plats){
        if (!aabb(boxV, p)) continue;
        const prevY = player.y;
        if (player.vy > 0 && prevY + player.h <= p.y + 2){
          ny = p.y - player.h;
          player.vy = 0;
          player.onGround = true;
          if (!inDash && Math.random() < 0.40) addSplash(player.x + player.w/2, ny + player.h + 2, 0.7);
        } else if (player.vy < 0 && prevY >= p.y + p.h - 2){
          ny = p.y + p.h;
          player.vy = 40;
        }
        boxV.y = ny;
      }

      const boxH = { x:nx, y:ny, w:player.w, h:player.h };
      for (const p of plats){
        if (!aabb(boxH, p)) continue;
        const prevX = player.x;
        if (player.vx > 0 && prevX + player.w <= p.x + 2){
          nx = p.x - player.w;
          player.vx = 0;
        } else if (player.vx < 0 && prevX >= p.x + p.w - 2){
          nx = p.x + p.w;
          player.vx = 0;
        }
        boxH.x = nx;
      }

      player.x = nx;
      player.y = ny;

      if (player.onGround){
        player.jumpsLeft = 1;
        player.canDash = true;
      }

      player.bob += dt * (player.onGround ? 4.4 : 2.4);
      player.blink -= dt;
      if (player.blink < 0 && Math.random() < 0.02){
        player.blink = 0.12 + Math.random()*0.14;
      }

      player.inv = Math.max(0, player.inv - dt);
    }

    function stepTail(dt){
      if (!tail.initialized) initTail();

      const bob = Math.sin(player.bob) * (player.onGround ? 0.7 : 0.35);

      // anchor: attach behind the head so it reads like a horizontal lil dragon
      const baseX = player.x + player.w/2 - player.face * 6;
      const baseY = player.y + 9 + bob;

      tail.pts[0].x = baseX;
      tail.pts[0].y = baseY;
      tail.pts[0].vx = 0;
      tail.pts[0].vy = 0;

      const soft = ui.soft.checked;
      const damp = soft ? 0.86 : 0.82;
      const k = soft ? 86 : 104;

      const windForce = windNow * (soft ? 0.18 : 0.22);

      // IMPORTANT: keep tail mostly horizontal
      const gravity = soft ? 95 : 120;          // way lower than before
      const levelK = soft ? 32 : 42;            // pulls segments toward baseY line

      for (let i=1;i<tail.pts.length;i++){
        const p = tail.pts[i];
        const prev = tail.pts[i-1];

        let dx = prev.x - p.x;
        let dy = prev.y - p.y;
        const dist = Math.max(0.001, Math.hypot(dx,dy));
        const diff = dist - tail.len;

        const ax = (dx/dist) * diff * k;
        const ay = (dy/dist) * diff * k;

        const targetY = baseY + (Math.sin((i*0.55) + performance.now()*0.0012) * (soft ? 0.6 : 0.9));
        const levelAy = (targetY - p.y) * levelK;

        p.vx = p.vx * damp + ax * dt + windForce * dt - player.vx * 0.009 * dt;
        p.vy = p.vy * damp + ay * dt + gravity * dt + levelAy * dt + player.vy * 0.004 * dt;

        p.x += p.vx;
        p.y += p.vy;

        p.x = clamp(p.x, -40, W()+40);
        p.y = clamp(p.y, -40, H()+80);
      }

      for (let pass=0; pass<2; pass++){
        for (let i=1;i<tail.pts.length;i++){
          const p = tail.pts[i];
          const prev = tail.pts[i-1];
          let dx = p.x - prev.x;
          let dy = p.y - prev.y;
          const dist = Math.max(0.001, Math.hypot(dx,dy));
          const err = dist - tail.len;
          const nx = dx/dist;
          const ny = dy/dist;
          p.x -= nx * err * 0.86;
          p.y -= ny * err * 0.86;
        }
      }
    }

    // -------- storm / wetness / shelter
    function stepStorm(dt){
      const soft = ui.soft.checked;
      storm.t += dt;

      windTarget = (Number(ui.wind.value) * 2 - 1) * (soft ? 110 : 160);
      windNow = lerp(windNow, windTarget, 1 - Math.pow(0.001, dt));

      const cycle = soft ? 46 : 52;
      const t = storm.t % cycle;

      if (t < cycle*0.42){
        if (storm.phase !== "calm"){
          storm.phase = "calm";
          setChipState("calm");
          $("moodOut").textContent = "soft rain";
          $("shelterOut").textContent = "stable";
        }
      } else if (t < cycle*0.68){
        if (storm.phase !== "building"){
          storm.phase = "building";
          setChipState("building");
          $("moodOut").textContent = "pressure rising";
          $("shelterOut").textContent = "recommended";
        }
      } else {
        if (storm.phase !== "storm"){
          storm.phase = "storm";
          setChipState("storm");
          $("moodOut").textContent = "full storm";
          $("shelterOut").textContent = "get inside";
        }
      }

      const inside = inShelter(player.x, player.y);
      const rainI = Number(ui.rain.value);
      const wetGain = (storm.phase === "storm" ? 26 : storm.phase === "building" ? 18 : 10);
      const wetLoss = 34;

      if (!inside){
        wetness = clamp(wetness + wetGain * rainI * dt, 0, 100);
      } else {
        wetness = clamp(wetness - wetLoss * dt, 0, 100);
      }

      if (storm.phase === "storm" && !inside && wetness > 85){
        if (player.inv <= 0){
          hp = Math.max(0, hp - 1);
          player.inv = soft ? 1.2 : 0.9;
          storm.shake = Math.min(1, storm.shake + (soft ? 0.10 : 0.18));
          tailKick(0.6);
        }
      }

      const thunderChance = Number(ui.thunder.value);
      storm.nextLightning -= dt * (storm.phase === "storm" ? 1.6 : storm.phase === "building" ? 1.0 : 0.65);
      if (storm.nextLightning <= 0){
        storm.nextLightning = (soft ? 1.8 : 1.2) + Math.random()*2.2;
        if (Math.random() < thunderChance){
          storm.flash = 1;
          if (!soft) storm.shake = Math.min(1, storm.shake + 0.22);
        }
      }

      storm.flash = Math.max(0, storm.flash - dt * (soft ? 3.0 : 4.5));
      storm.shake = Math.max(0, storm.shake - dt * (soft ? 1.4 : 1.9));
    }

    // -------- rendering
    function drawBackground(w,h){
      const g1 = ctx.createLinearGradient(0,0,0,h);
      g1.addColorStop(0, "rgba(0,0,0,0.10)");
      g1.addColorStop(1, "rgba(0,0,0,0.55)");
      ctx.fillStyle = g1;
      ctx.fillRect(0,0,w,h);

      ctx.save();
      ctx.globalAlpha = 0.30;
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      const par = windNow * 0.02;
      for (let i=0;i<10;i++){
        const bw = 90 + (i%3)*60;
        const bh = 40 + (i%4)*45;
        const x = (i*140 + par + (seed%97)) % (w + 220) - 120;
        const y = 60 + (i%5)*52;
        ctx.fillRect(x, y, bw, bh);
      }
      ctx.restore();

      ctx.save();
      ctx.globalAlpha = 0.14;
      ctx.fillStyle = "rgba(255,120,200,0.16)";
      const fogY = 120 + Math.sin(performance.now()*0.0004) * 10;
      ctx.fillRect(-20, fogY, w+40, 70);
      ctx.globalAlpha = 0.09;
      ctx.fillRect(-20, fogY+140, w+40, 90);
      ctx.restore();
    }

    function drawPlatforms(){
      const w = W(), h = H();
      for (const p of plats){
        if (p.kind === "ground"){
          ctx.fillStyle = "rgba(0,0,0,0.55)";
          ctx.fillRect(p.x, p.y, p.w, p.h);
          ctx.fillStyle = "rgba(255,179,230,0.10)";
          ctx.fillRect(0, p.y, w, 2);
          continue;
        }

        const isPillar = p.kind === "pillar";
        ctx.fillStyle = isPillar ? "rgba(0,0,0,0.46)" : "rgba(0,0,0,0.40)";
        ctx.fillRect(p.x, p.y, p.w, p.h);

        ctx.strokeStyle = "rgba(255,255,255,0.10)";
        ctx.lineWidth = 1;
        ctx.strokeRect(p.x+0.5, p.y+0.5, p.w-1, p.h-1);

        ctx.strokeStyle = "rgba(255,120,200,0.14)";
        ctx.beginPath();
        ctx.moveTo(p.x, p.y+1);
        ctx.lineTo(p.x+p.w, p.y+1);
        ctx.stroke();
      }

      ctx.save();
      const glow = 0.18 + Math.sin(performance.now()*0.004) * 0.06;
      ctx.fillStyle = "rgba(0,0,0,0.52)";
      ctx.fillRect(shelter.x, shelter.y, shelter.w, shelter.h);

      ctx.strokeStyle = `rgba(255,179,230,${0.38 + glow*0.9})`;
      ctx.lineWidth = 2;
      ctx.strokeRect(shelter.x+1, shelter.y+1, shelter.w-2, shelter.h-2);

      ctx.fillStyle = `rgba(255,120,200,${0.08 + glow})`;
      const dx = shelter.x + shelter.w*0.32;
      const dy = shelter.y + shelter.h*0.30;
      const dw = shelter.w*0.36;
      const dh = shelter.h*0.52;
      ctx.fillRect(dx, dy, dw, dh);

      ctx.font = `12px ${getComputedStyle(document.documentElement).getPropertyValue("--mono") || "ui-monospace, monospace"}`;
      ctx.fillStyle = "rgba(255,179,230,0.82)";
      ctx.fillText("shelter", shelter.x + 10, shelter.y + 16);
      ctx.restore();
    }

    function drawSpores(dt){
      ctx.save();
      const t = performance.now() * 0.001;
      for (const s of sporeList){
        if (!s.alive) continue;
        s.bob += dt * 1.8;
        s.x += s.vx * (ui.soft.checked ? 0.6 : 1);

        if (s.x < 30) s.x = W()-30;
        if (s.x > W()-30) s.x = 30;

        const yy = s.y + Math.sin(s.bob + t) * 6;
        const pulse = 0.55 + Math.sin(s.bob*2.0 + t*2.3) * 0.18;

        ctx.globalAlpha = 0.20;
        ctx.fillStyle = "rgba(255,120,200,0.45)";
        ctx.beginPath();
        ctx.arc(s.x, yy, s.r*2.1, 0, Math.PI*2);
        ctx.fill();

        ctx.globalAlpha = 0.90;
        ctx.fillStyle = "rgba(255,255,255,0.82)";
        ctx.beginPath();
        ctx.arc(s.x, yy, s.r*0.9, 0, Math.PI*2);
        ctx.fill();

        ctx.globalAlpha = pulse;
        ctx.strokeStyle = "rgba(255,179,230,0.72)";
        ctx.lineWidth = 1.1;
        ctx.beginPath();
        ctx.arc(s.x, yy, s.r*1.3, 0, Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function roundRectCentered(w,h,r){
      r = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(-w/2 + r, -h/2);
      ctx.arcTo( w/2, -h/2,  w/2,  h/2, r);
      ctx.arcTo( w/2,  h/2, -w/2,  h/2, r);
      ctx.arcTo(-w/2,  h/2, -w/2, -h/2, r);
      ctx.arcTo(-w/2, -h/2,  w/2, -h/2, r);
      ctx.closePath();
    }

    function drawTinyDragon(){
      const soft = ui.soft.checked;

      // optional shake
      const shake = soft ? 0 : storm.shake;
      const sx = (Math.random()-0.5) * 6 * shake;
      const sy = (Math.random()-0.5) * 6 * shake;

      ctx.save();
      ctx.translate(sx, sy);

      const bob = Math.sin(player.bob) * (player.onGround ? 0.7 : 0.35);

      // head point (front)
      const headX = player.x + player.w/2 + player.face * 8;
      const headY = player.y + 8 + bob;

      // shadow
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "rgba(0,0,0,0.75)";
      ctx.beginPath();
      ctx.ellipse(player.x + player.w/2, player.y + player.h + 8, 16, 5, 0, 0, Math.PI*2);
      ctx.fill();

      const invBlink = player.inv > 0 ? (Math.floor(performance.now()/70)%2===0) : false;
      ctx.globalAlpha = invBlink ? 0.35 : 1;

      const wetGlow = wetness / 100;

      // styling: less bright, thinner
      const strokeA = 0.52 + wetGlow * 0.12;
      ctx.strokeStyle = `rgba(255,120,200,${strokeA})`;
      ctx.fillStyle = "rgba(8,8,10,0.98)";
      ctx.lineWidth = 2;
      ctx.lineJoin = "round";

      ctx.shadowColor = "rgba(255,120,200,0.25)";
      ctx.shadowBlur = 6 + wetGlow * 6;

      // build spine points: head + tail chain
      const spine = [];
      spine.push({ x: headX, y: headY });

      // use tail points but flip order so it trails behind head cleanly
      if (!tail.initialized) initTail();
      for (let i=0;i<tail.pts.length;i++){
        spine.push({ x: tail.pts[i].x, y: tail.pts[i].y });
      }

      // draw segments from head -> back
      const n = spine.length;

      for (let i=0;i<n-1;i++){
        const p = spine[i];
        const q = spine[i+1];
        const dx = q.x - p.x;
        const dy = q.y - p.y;
        const ang = Math.atan2(dy, dx);

        const t = i / (n-1);
        const segW = lerp(14, 6, t);
        const segH = lerp(10, 5, t);

        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(ang);

        // body segment
        roundRectCentered(segW, segH, 3.2);
        ctx.fill();
        ctx.stroke();

        // little spikes (top ridge), skip head + last few
        if (i >= 2 && i <= n-6){
          const spike = 3.2 - t*1.6;
          ctx.beginPath();
          ctx.moveTo(-segW*0.10, -segH/2);
          ctx.lineTo(0, -segH/2 - spike);
          ctx.lineTo(segW*0.14, -segH/2);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        }

        // tiny legs-ish bumps (low key)
        if (i === 3 || i === 5){
          ctx.beginPath();
          ctx.moveTo(-segW*0.15, segH/2);
          ctx.lineTo(-segW*0.05, segH/2 + 2.3);
          ctx.lineTo(segW*0.10, segH/2);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
        }

        ctx.restore();
      }

      // head details (snout + eye)
      ctx.save();
      const neck = spine[1] || spine[0];
      const hx = spine[0].x, hy = spine[0].y;
      const hdx = hx - neck.x;
      const hdy = hy - neck.y;
      const hang = Math.atan2(hdy, hdx);

      ctx.translate(hx, hy);
      ctx.rotate(hang);

      // snout
      ctx.beginPath();
      ctx.moveTo(6, 0);
      ctx.lineTo(14, -2);
      ctx.lineTo(14, 2);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // ear/horn
      ctx.beginPath();
      ctx.moveTo(2, -5);
      ctx.lineTo(6, -10);
      ctx.lineTo(8, -4);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // eye
      ctx.shadowBlur = 0;
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.beginPath();
      ctx.arc(3.5, -1.2, 1.2, 0, Math.PI*2);
      ctx.fill();

      // blush pixel
      ctx.fillStyle = "rgba(255,120,200,0.40)";
      ctx.fillRect(1.2, 1.2, 2, 1);

      ctx.restore();

      ctx.restore();
    }

    function drawRain(dt){
      const w = W(), h = H();
      const soft = ui.soft.checked;

      const intensity = Number(ui.rain.value);
      const n = drops.length;

      const vx = windNow * (soft ? 0.65 : 1);
      const slope = vx * 0.0028;

      ctx.save();
      ctx.globalAlpha = 0.52;
      ctx.lineWidth = 1.2;
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.shadowColor = "rgba(255,120,200,0.12)";
      ctx.shadowBlur = 10;

      const speedMul = lerp(0.7, 1.45, intensity) * (storm.phase === "storm" ? 1.35 : storm.phase === "building" ? 1.10 : 1.0);

      for (let i=0;i<n;i++){
        const d = drops[i];
        d.y += d.spd * speedMul * dt;
        d.x += vx * (0.25 + d.z*0.75) * dt;

        if (d.y > h + 20){
          d.y = -20 - sRand()*40;
          d.x = sRand() * w;
          if (Math.random() < 0.07 * intensity){
            addSplash(d.x, h-54, 0.6);
          }
        }
        if (d.x < -40) d.x = w + 40;
        if (d.x > w + 40) d.x = -40;

        const x2 = d.x + slope * d.len;
        const y2 = d.y + d.len;

        ctx.beginPath();
        ctx.moveTo(d.x, d.y);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      ctx.restore();

      ctx.save();
      ctx.fillStyle = "rgba(255,179,230,0.55)";
      for (let i=splashes.length-1;i>=0;i--){
        const s = splashes[i];
        s.t += dt;
        s.x += s.vx * dt;
        s.y += s.vy * dt;
        s.vy += 320 * dt;
        const lifeT = s.t / s.life;
        const a = 1 - lifeT;
        ctx.globalAlpha = 0.55 * a;
        ctx.beginPath();
        ctx.arc(s.x, s.y, 1.2 + (1-lifeT)*1.1, 0, Math.PI*2);
        ctx.fill();
        if (lifeT >= 1) splashes.splice(i,1);
      }
      ctx.restore();
    }

    function drawLightning(){
      if (storm.flash <= 0) return;
      const soft = ui.soft.checked;
      if (soft) return;

      const w = W(), h = H();
      ctx.save();
      ctx.globalAlpha = 0.40 * storm.flash;
      ctx.fillStyle = "rgba(255,255,255,1)";
      ctx.fillRect(0,0,w,h);

      ctx.globalAlpha = 0.22 * storm.flash;
      ctx.fillStyle = "rgba(255,120,200,1)";
      ctx.fillRect(0,0,w,h);
      ctx.restore();
    }

    function drawVignette(){
      const w = W(), h = H();
      ctx.save();
      const g = ctx.createRadialGradient(w*0.5, h*0.35, 80, w*0.5, h*0.5, Math.max(w,h)*0.75);
      g.addColorStop(0, "rgba(0,0,0,0)");
      g.addColorStop(1, "rgba(0,0,0,0.55)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,w,h);
      ctx.restore();
    }

    // -------- ui sync
    function syncUI(){
      $("vJump").textContent = String(Math.round(Number(ui.jump.value)));
      $("vRain").textContent = Number(ui.rain.value).toFixed(2);
      $("vWind").textContent = Number(ui.wind.value).toFixed(2);
      $("vThunder").textContent = Number(ui.thunder.value).toFixed(2);

      makeRain();
      spawnSpores(false);

      setHum(ui.hum.checked);

      saveSettings();
    }
    ui.jump.addEventListener("input", syncUI);
    ui.rain.addEventListener("input", syncUI);
    ui.wind.addEventListener("input", syncUI);
    ui.thunder.addEventListener("input", syncUI);
    ui.soft.addEventListener("change", syncUI);
    ui.hum.addEventListener("change", syncUI);
    syncUI();

    // -------- buttons
    function togglePause(){
      paused = !paused;
      $("btnPause").innerHTML = paused ? `<span class="k">▶</span> resume` : `<span class="k">⏸</span> pause`;
    }

    $("btnPause").addEventListener("click", togglePause);
    $("btnReset").addEventListener("click", () => rollBiome());
    $("btnReroll").addEventListener("click", () => rollBiome());

    $("btnScreenshot").addEventListener("click", () => {
      const a = document.createElement("a");
      a.href = cv.toDataURL("image/png");
      a.download = "rain-biome.png";
      document.body.appendChild(a);
      a.click();
      a.remove();
    });

    // -------- roll/reset biome
    function rollBiome(){
      reseed();
      makePlatforms();
      spawnSpores(true);

      storm.t = 0;
      storm.phase = "calm";
      storm.nextLightning = 0.8 + sRand()*2.0;
      storm.flash = 0;
      storm.shake = 0;

      setChipState("calm");
      $("moodOut").textContent = "soft rain";
      $("shelterOut").textContent = "stable";

      wetness = 0;
      hp = 6;
      spores = 0;

      player.x = 80;
      player.y = H() - 140;
      player.vx = 0;
      player.vy = 0;
      player.inv = 0;
      player.jumpsLeft = 1;
      player.canDash = true;
      player.dashTimer = 0;
      player.dashCd = 0;

      initTail();
      updateChips();
    }

    // -------- loop
    let last = performance.now();
    function loop(now){
      requestAnimationFrame(loop);
      fit();

      const dt = clamp((now - last) / 1000, 0, 0.033);
      last = now;

      if (!paused){
        stepStorm(dt);
        stepPlayer(dt);
        stepTail(dt);
        collectCheck();

        const inside = inShelter(player.x, player.y);
        if (storm.phase === "storm" && !inside){
          $("moodOut").textContent = hp <= 2 ? "low hp, get safe" : (wetness > 70 ? "soaked" : "storming");
        } else if (inside){
          $("moodOut").textContent = "safe in shelter";
        } else if (storm.phase === "building"){
          $("moodOut").textContent = "storm building";
        } else {
          $("moodOut").textContent = "soft rain";
        }

        if (hp <= 0){
          paused = true;
          $("btnPause").innerHTML = `<span class="k">▶</span> resume`;
          $("moodOut").textContent = "hp 0 (rip). press r.";
        }

        updateChips();
      }

      pressed.clear();

      const w = W(), h = H();
      ctx.clearRect(0,0,w,h);

      drawBackground(w,h);
      drawPlatforms();
      drawSpores(dt);
      drawRain(dt);

      // creature last so it sits on top of rain
      drawTinyDragon();

      drawLightning();
      drawVignette();

      const inside = inShelter(player.x, player.y);
      $("shelterOut").textContent = inside ? "inside" : (storm.phase === "storm" ? "danger" : "open");
    }
    requestAnimationFrame(loop);

    // start
    rollBiome();
  </script>
</body>
</html>
